/*
* Copyright 2017, Simula Research Laboratory
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

#include <float.h>


#include "sift_matching.h"
#include "assist.h"
#include "sift_conf.h"
#include "sift_octave.h"
#include "sift_pyramid.h"
#include "sift_extremum.h"
#include "popsift.h"
#include "common/debug_macros.h"
#include "cuda.h"
#include "cublas.h"
#include "cuda_runtime.h"
#include "device_launch_parameters.h"

namespace popsift {

__global__
void ConvertDescriptorsToU8(Descriptor* d_desc, size_t count, U8Descriptor* out) {
    int tid = threadIdx.x;
    for (int i = tid; i < count; i += blockDim.x) {
        for (int x = 0; x < 128; x++) {
            unsigned int tmp = d_desc[i].features[x] * 512;
            out[i].features[x] = tmp;
        }
    }
}

// Does not synchronize. Need to syncrhonize stream or device before using the returned value
U8Descriptor* ConvertDescriptorsToU8(Descriptor* d_descriptors, size_t count, cudaStream_t stream)
{
    U8Descriptor* u8d_descriptors = popsift::cuda::malloc_devT<U8Descriptor>(count, __FILE__, __LINE__);
    int threads_per_block = 64;
    int block_count = (int)ceil(count / (float)threads_per_block);
    if (stream) {
        ConvertDescriptorsToU8 <<<block_count, threads_per_block, 0, stream>>> (d_descriptors, count, u8d_descriptors);
    }
    else {
        ConvertDescriptorsToU8 << <block_count, threads_per_block, 0>> > (d_descriptors, count, u8d_descriptors);
    }
    return u8d_descriptors;
}

Matching::Matching(Config& config)
 : config(config) {
}

Matching::~Matching() {

}


std::vector<std::vector<std::pair<size_t, size_t>>> Matching::Match(popsift::Descriptor * device_desc_a, size_t num_a,
                                                       std::vector<std::pair<popsift::Descriptor*, size_t>> database_descs)
{
    // each database image is in part processed on its own stream, and cant have more than 1024 cuda streams
    // Some streams are also generated by descriptor-extraction code, so most likely we cant even create 1024 more, but since
    // we most likely have between 5 and 10 database images, this is not really an issue.
    assert(database_descs.size() <= 512);
    
    //creating streams. Starting by destroying old ones if we have any. Could reuse same streams but lazyness.
    while (!streams.empty()) {
        popsift::cuda::stream_destroy(streams.back(), __FILE__, __LINE__);
        streams.pop_back();
    }
    // Allocating one extra stream for the conversion and download of a-descriptors
    for (size_t i = 0; i < database_descs.size()+1; i++) {
        streams.push_back(popsift::cuda::stream_create(__FILE__, __LINE__));
        cudaStreamCreate(&streams[i]);
    }

    // Brute force matching all a descriptors against all b descriptors and getting the results
    auto distances = CalcDistances(device_desc_a, num_a, database_descs);
    assert(distances.size() == database_descs.size());
    
    //Converting descriptors to U8Descriptors. ConvertDescriptorsToU8 does not synchronize. Synchronization is done later in function.
    popsift::U8Descriptor* device_u8desc_a = ConvertDescriptorsToU8(device_desc_a, num_a, streams.back());
    std::vector<popsift::U8Descriptor*> device_database_u8descs;
    for (int k = 0; k < database_descs.size(); k++) {
        device_database_u8descs.at(k) = ConvertDescriptorsToU8(database_descs.at(k).first, database_descs.at(k).second, streams.at(k));
    }

    // start download of U8Descriptors from gpu to cpu
    popsift::U8Descriptor* cpu_descs_a = popsift::cuda::malloc_hstT<popsift::U8Descriptor>(num_a, __FILE__, __LINE__);
    cudaMemcpyAsync(cpu_descs_a, device_u8desc_a, sizeof(popsift::U8Descriptor)*num_a, cudaMemcpyDeviceToHost);

    std::vector<popsift::U8Descriptor*> cpu_database_descs;
    for (int k = 0; k < device_database_u8descs.size(); k++) {
        cpu_database_descs.at(k) = popsift::cuda::malloc_hstT<popsift::U8Descriptor>(database_descs.at(k).second, __FILE__, __LINE__);
        cudaMemcpyAsync(cpu_database_descs.at(k), device_database_u8descs.at(k), sizeof(popsift::U8Descriptor)*database_descs.at(k).second, cudaMemcpyDeviceToHost);
    }
    

    struct matchCandidate {
        size_t aIdx;
        size_t bIdx1, bIdx2;
    };
    // matchCandidates[k] is a vector of matchCandidate indexes
    std::vector<std::vector<matchCandidate>> matchCandidates;
    for (size_t k = 0; k < distances.size(); k++) {
        matchCandidates.push_back(std::vector<matchCandidate>());

        for (size_t i = 0; i < num_a; i++) {
            float max1 = 0.0f, max2 = 0.0f;
            size_t index1 = 0, index2 = 0;
            for (size_t j = 0; j < database_descs.at(k).second; j++) {
                // dist is a cosinus-distance, so no distance means dist=1,
                // while maximum distance means dist=0
                size_t idx = num_a*i + j;
                float dist = distances.at(k)[num_a*i + j];
                if (dist > max1) {
                    max2 = max1;
                    index2 = index1;
                    max1 = dist;
                    index1 = idx;
                }
                else if (dist > max2) {
                    max2 = dist;
                    index2 = idx;
                }
            }
            matchCandidates.at(k).push_back(matchCandidate{i, index1, index2});
        }
    }

    std::vector<std::vector<std::pair<size_t, size_t>>> result;
    cudaStreamSynchronize(streams.back());
    for (size_t k = 0; k < matchCandidates.size(); k++) {
        std::vector<std::pair<size_t, size_t>> imgResult;
        result.push_back(imgResult);
        
        cudaStreamSynchronize(streams.at(k));
        for (size_t c = 0; c < matchCandidates.at(k).size(); c++) {
            const matchCandidate& mc = matchCandidates.at(k).at(c);
            const popsift::U8Descriptor& desc_a = cpu_descs_a[mc.aIdx];
            const popsift::U8Descriptor& desc_b1 = cpu_database_descs.at(k)[mc.bIdx1];
            const popsift::U8Descriptor& desc_b2 = cpu_database_descs.at(k)[mc.bIdx2];
            float d1 = L2DistanceSquared(desc_a, desc_b1);
            float d2 = L2DistanceSquared(desc_a, desc_b2);
            
            //0.8 sinceL2DistanceSquared sqrt
            // if d1 == 0 there is no distance and it's also a match
            if (d1 == 0 || d2 / d1 < 0.8f) { 
                imgResult.push_back(std::make_pair(mc.aIdx, mc.bIdx1));
            }
        }
    }
    return result;
}

void calcDistMat(Descriptor* a, Descriptor* b, int numA, int numB, float* res) {
    for (int ai = 0; ai < numA; ai++) {
        for (int bi = 0; bi < numB; bi++) {
            size_t outi = ai + numB*bi;
            res[outi] = 0.0;
            for (int i = 0; i < 128; i++) {
                res[outi] += a[ai].features[i] * b[bi].features[i];
            }
        }
    }
}

std::vector<float*> Matching::CalcDistances(popsift::Descriptor* device_desc_a, size_t num_a,
    std::vector<std::pair<popsift::Descriptor*, size_t>> database_descs)
{
    std::vector<float*> result;
    
    
    // Cuda currently support <= 1024 streams. In this scenario a number closer to 10
    // is ideal, but since we will mostly operate with around 5 database descriptor sets,
    // it should be no problem.
    

    cublasHandle_t handle;
    cublasCreate_v2(&handle);
    static const float alpha = 1.0f;
    static const float beta  = 0.0f;


    for (size_t i = 0; i < database_descs.size(); i++) {
        cublasSetStream_v2(handle, streams[i]);
        const std::pair<popsift::Descriptor*, size_t>& b_descs = database_descs.at(i);
        
        size_t num_result = num_a*b_descs.second;

        float* device_result = popsift::cuda::malloc_devT<float>(num_result, __FILE__, __LINE__);
        cublasSgemm_v2(
            handle,
            CUBLAS_OP_T,            // A transposed
            CUBLAS_OP_N,            // B not transposed
            num_a,                  // m
            b_descs.second,         // n
            128,                    // k
            &alpha,                // alpha
            (float*)device_desc_a,  // A
            128,                    // lda
            (float*)b_descs.first,  // B
            128,                    // ldb
            &beta,                  // beta XXX: was &alpha in old code, is &beta correct?
            device_result,          // C
            num_a                   // ldc, XXX: not sure if num_a or 128 (LDC=max(1,m))
        );
        float* gpu_res = popsift::cuda::malloc_hstT<float>(num_result, __FILE__, __LINE__);
        cudaMemcpyAsync(gpu_res, device_result, sizeof(float)*num_result, cudaMemcpyDeviceToHost, streams[i]);
        result.push_back(gpu_res);
    }
    
    cudaDeviceSynchronize(); 

#if 1 // bruteforce cpu matching for validation
    for (size_t i = 0; i < database_descs.size(); i++) {
        const std::pair<popsift::Descriptor*, size_t>& b_descs = database_descs.at(i);
        size_t num_result = num_a*b_descs.second;
        float* cpu_res = popsift::cuda::malloc_hstT<float>(num_result, __FILE__, __LINE__);
        calcDistMat(device_desc_a, b_descs.first, num_a, b_descs.second, cpu_res);
        int num_match = 0;
        for (int x = 0; x < num_result; x++) {
            // Expecting differences due to different algorithm and gpu and cpu. Can add an epsilon in test.
            if (result.at(i)[x] == cpu_res[x])
                num_match++;
        }
        std::cout << "popsift cublas matching got " << num_match << "/" << num_result 
                  << " correct distance calculations" << std::endl;
    }
#endif 
    cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        std::cout << "popsift cublas matching got error: " << cudaGetErrorString(err);
    }
    return result;
}

}
